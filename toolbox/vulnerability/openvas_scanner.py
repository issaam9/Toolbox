#!/usr/bin/env python3
"""
OpenVAS Automation pour CyberSec Pro
Module d'automatisation des scans de vuln√©rabilit√©s avec OpenVAS
"""

import os
import time
import json
import subprocess
import xml.etree.ElementTree as ET
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import logging
import socket
import threading
from pathlib import Path

class OpenVASAutomation:
    """Automatisation des scans OpenVAS/GVM"""
    
    def __init__(self, gvm_host="127.0.0.1", gvm_port=9390, username="admin", password="admin"):
        self.gvm_host = gvm_host
        self.gvm_port = gvm_port
        self.username = username
        self.password = password
        
        # Configuration des scans
        self.scan_configs = self.load_scan_configurations()
        self.active_scans = {}
        self.scan_history = []
        
        self.setup_logging()
        self.check_openvas_status()
    
    def setup_logging(self):
        """Configuration du logging"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - OpenVASAutomation - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)
    
    def check_openvas_status(self):
        """V√©rifier le statut d'OpenVAS/GVM"""
        try:
            # V√©rifier si le service GVM est accessible
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((self.gvm_host, self.gvm_port))
            sock.close()
            
            if result == 0:
                self.logger.info("OpenVAS/GVM d√©tect√© et accessible")
                self.openvas_available = True
            else:
                self.logger.warning("OpenVAS/GVM non accessible, mode simulation activ√©")
                self.openvas_available = False
                
        except Exception as e:
            self.logger.error(f"Erreur lors de la v√©rification OpenVAS: {e}")
            self.openvas_available = False
    
    def load_scan_configurations(self):
        """Charger les configurations de scan pr√©d√©finies"""
        return {
            'quick_scan': {
                'name': 'Quick Vulnerability Scan',
                'description': 'Scan rapide des vuln√©rabilit√©s critiques',
                'config_id': 'daba56c8-73ec-11df-a475-002264764cea',  # Full and fast
                'scanner_id': '08b69003-5fc2-4037-a479-93b440211c73',  # OpenVAS Scanner
                'port_list': 'T:1-65535',
                'estimated_time': 30,  # minutes
                'targets': []
            },
            'full_scan': {
                'name': 'Full Vulnerability Assessment',
                'description': 'Scan complet et approfondi',
                'config_id': '74db13d6-7489-11df-a475-002264764cea',  # Full and fast ultimate
                'scanner_id': '08b69003-5fc2-4037-a479-93b440211c73',
                'port_list': 'T:1-65535,U:1-1024',
                'estimated_time': 120,  # minutes
                'targets': []
            },
            'web_scan': {
                'name': 'Web Application Scan',
                'description': 'Scan sp√©cialis√© pour applications web',
                'config_id': '2d3f051c-55ba-11e3-bf43-406186ea4fc5',  # Web Application Tests
                'scanner_id': '08b69003-5fc2-4037-a479-93b440211c73',
                'port_list': 'T:80,443,8080,8443',
                'estimated_time': 45,
                'targets': []
            },
            'network_scan': {
                'name': 'Network Infrastructure Scan',
                'description': 'Scan des √©quipements r√©seau',
                'config_id': 'bbca7412-a950-11e3-9109-406186ea4fc5',  # System Discovery
                'scanner_id': '08b69003-5fc2-4037-a479-93b440211c73',
                'port_list': 'T:1-1024',
                'estimated_time': 60,
                'targets': []
            }
        }
    
    def automated_scan(self, target, scan_type='quick_scan', scheduled_time=None):
        """Lancer un scan automatis√©"""
        self.logger.info(f"D√©marrage du scan automatis√© {scan_type} sur {target}")
        
        if not self.openvas_available:
            return self.simulate_openvas_scan(target, scan_type)
        
        try:
            # Cr√©er la cible
            target_id = self.create_target(target)
            if not target_id:
                return self.create_error_report("Impossible de cr√©er la cible")
            
            # Cr√©er la t√¢che de scan
            task_id = self.create_scan_task(target_id, scan_type)
            if not task_id:
                return self.create_error_report("Impossible de cr√©er la t√¢che de scan")
            
            # Programmer ou d√©marrer le scan
            if scheduled_time:
                return self.schedule_scan(task_id, scheduled_time)
            else:
                return self.start_scan_and_monitor(task_id, target, scan_type)
                
        except Exception as e:
            self.logger.error(f"Erreur lors du scan automatis√©: {e}")
            return self.create_error_report(str(e))
    
    def simulate_openvas_scan(self, target, scan_type):
        """Simuler un scan OpenVAS quand le service n'est pas disponible"""
        self.logger.info(f"Simulation du scan OpenVAS {scan_type} sur {target}")
        
        config = self.scan_configs.get(scan_type, self.scan_configs['quick_scan'])
        
        # Simulation des vuln√©rabilit√©s trouv√©es
        simulated_vulnerabilities = self.generate_simulated_vulnerabilities(target, scan_type)
        
        # G√©n√©rer le rapport de simulation
        report = self.generate_simulation_report(target, scan_type, config, simulated_vulnerabilities)
        
        return report
    
    def generate_simulated_vulnerabilities(self, target, scan_type):
        """G√©n√©rer des vuln√©rabilit√©s simul√©es"""
        
        base_vulnerabilities = [
            {
                'name': 'OpenSSH Information Disclosure',
                'severity': 'Medium',
                'cvss': 5.3,
                'cve': 'CVE-2018-15473',
                'port': 22,
                'service': 'ssh',
                'description': 'OpenSSH user enumeration vulnerability',
                'solution': 'Update OpenSSH to latest version'
            },
            {
                'name': 'Apache HTTP Server Information Disclosure',
                'severity': 'Low',
                'cvss': 2.6,
                'cve': 'CVE-2019-0220',
                'port': 80,
                'service': 'http',
                'description': 'Apache HTTP Server mod_auth_digest denial of service',
                'solution': 'Update Apache to version 2.4.39 or later'
            },
            {
                'name': 'SSL/TLS Weak Cipher Suites',
                'severity': 'Medium',
                'cvss': 4.3,
                'cve': 'N/A',
                'port': 443,
                'service': 'https',
                'description': 'Weak cipher suites detected',
                'solution': 'Configure strong cipher suites'
            }
        ]
        
        # Vuln√©rabilit√©s sp√©cifiques selon le type de scan
        if scan_type == 'web_scan':
            base_vulnerabilities.extend([
                {
                    'name': 'Cross-Site Scripting (XSS)',
                    'severity': 'High',
                    'cvss': 6.1,
                    'cve': 'N/A',
                    'port': 80,
                    'service': 'http',
                    'description': 'Reflected XSS vulnerability detected',
                    'solution': 'Implement input validation and output encoding'
                },
                {
                    'name': 'SQL Injection',
                    'severity': 'Critical',
                    'cvss': 9.8,
                    'cve': 'N/A',
                    'port': 80,
                    'service': 'http',
                    'description': 'SQL injection vulnerability in login form',
                    'solution': 'Use parameterized queries'
                }
            ])
        
        elif scan_type == 'full_scan':
            base_vulnerabilities.extend([
                {
                    'name': 'SMB Signing Not Required',
                    'severity': 'Medium',
                    'cvss': 5.9,
                    'cve': 'N/A',
                    'port': 445,
                    'service': 'smb',
                    'description': 'SMB signing is not required',
                    'solution': 'Enable SMB signing'
                },
                {
                    'name': 'Outdated Operating System',
                    'severity': 'High',
                    'cvss': 7.5,
                    'cve': 'Multiple',
                    'port': 0,
                    'service': 'general',
                    'description': 'Operating system is not up to date',
                    'solution': 'Install latest security updates'
                }
            ])
        
        return base_vulnerabilities
    
    def create_target(self, target_ip):
        """Cr√©er une cible dans OpenVAS"""
        if not self.openvas_available:
            return f"simulated_target_{target_ip}"
        
        # Commande GMP pour cr√©er une cible
        gmp_command = f"""
        <create_target>
            <name>Target_{target_ip}_{int(time.time())}</name>
            <hosts>{target_ip}</hosts>
            <port_list id="4a4717fe-57d2-11e1-9a26-406186ea4fc5"/>
        </create_target>
        """
        
        try:
            result = self.execute_gmp_command(gmp_command)
            # Parser la r√©ponse XML pour extraire l'ID
            root = ET.fromstring(result)
            target_id = root.get('id')
            return target_id
        except Exception as e:
            self.logger.error(f"Erreur cr√©ation cible: {e}")
            return None
    
    def create_scan_task(self, target_id, scan_type):
        """Cr√©er une t√¢che de scan"""
        if not self.openvas_available:
            return f"simulated_task_{scan_type}_{int(time.time())}"
        
        config = self.scan_configs.get(scan_type, self.scan_configs['quick_scan'])
        
        gmp_command = f"""
        <create_task>
            <name>{config['name']}_{int(time.time())}</name>
            <config id="{config['config_id']}"/>
            <target id="{target_id}"/>
            <scanner id="{config['scanner_id']}"/>
        </create_task>
        """
        
        try:
            result = self.execute_gmp_command(gmp_command)
            root = ET.fromstring(result)
            task_id = root.get('id')
            return task_id
        except Exception as e:
            self.logger.error(f"Erreur cr√©ation t√¢che: {e}")
            return None
    
    def start_scan_and_monitor(self, task_id, target, scan_type):
        """D√©marrer un scan et le monitorer"""
        self.logger.info(f"D√©marrage du scan {task_id}")
        
        if not self.openvas_available:
            return self.simulate_scan_monitoring(task_id, target, scan_type)
        
        # D√©marrer la t√¢che
        start_command = f'<start_task task_id="{task_id}"/>'
        
        try:
            self.execute_gmp_command(start_command)
            
            # Monitorer le scan
            return self.monitor_scan_progress(task_id, target, scan_type)
            
        except Exception as e:
            self.logger.error(f"Erreur d√©marrage scan: {e}")
            return self.create_error_report(str(e))
    
    def simulate_scan_monitoring(self, task_id, target, scan_type):
        """Simuler le monitoring d'un scan"""
        config = self.scan_configs.get(scan_type, self.scan_configs['quick_scan'])
        
        self.logger.info(f"Simulation du scan en cours... (dur√©e estim√©e: {config['estimated_time']} min)")
        
        # Simuler la progression
        progress_steps = [10, 25, 50, 75, 90, 100]
        
        for progress in progress_steps:
            self.logger.info(f"Progression du scan: {progress}%")
            time.sleep(1)  # Simulation rapide
        
        # G√©n√©rer le rapport final
        vulnerabilities = self.generate_simulated_vulnerabilities(target, scan_type)
        return self.generate_simulation_report(target, scan_type, config, vulnerabilities)
    
    def monitor_scan_progress(self, task_id, target, scan_type):
        """Monitorer la progression d'un scan r√©el"""
        config = self.scan_configs.get(scan_type, self.scan_configs['quick_scan'])
        start_time = datetime.now()
        
        while True:
            try:
                # Obtenir le statut de la t√¢che
                status_command = f'<get_tasks task_id="{task_id}"/>'
                result = self.execute_gmp_command(status_command)
                
                root = ET.fromstring(result)
                task = root.find('.//task')
                
                if task is not None:
                    status = task.find('status').text
                    progress = task.find('progress').text
                    
                    self.logger.info(f"Scan {task_id}: {status} - {progress}%")
                    
                    if status == 'Done':
                        # Obtenir le rapport
                        return self.get_scan_report(task_id, target, scan_type)
                    elif status == 'Stopped' or status == 'Interrupted':
                        return self.create_error_report(f"Scan arr√™t√©: {status}")
                
                # V√©rifier le timeout
                if datetime.now() - start_time > timedelta(minutes=config['estimated_time'] * 2):
                    return self.create_error_report("Timeout du scan")
                
                time.sleep(30)  # Attendre 30 secondes avant la prochaine v√©rification
                
            except Exception as e:
                self.logger.error(f"Erreur monitoring: {e}")
                return self.create_error_report(str(e))
    
    def get_scan_report(self, task_id, target, scan_type):
        """R√©cup√©rer le rapport de scan"""
        try:
            # Obtenir l'ID du dernier rapport pour cette t√¢che
            reports_command = f'<get_reports task_id="{task_id}"/>'
            result = self.execute_gmp_command(reports_command)
            
            root = ET.fromstring(result)
            reports = root.findall('.//report')
            
            if not reports:
                return self.create_error_report("Aucun rapport trouv√©")
            
            # Prendre le dernier rapport
            latest_report = reports[-1]
            report_id = latest_report.get('id')
            
            # Obtenir le contenu d√©taill√© du rapport
            detailed_command = f'<get_reports report_id="{report_id}" format_id="a994b278-1f62-11e1-96ac-406186ea4fc5"/>'
            detailed_result = self.execute_gmp_command(detailed_command)
            
            return self.parse_openvas_report(detailed_result, target, scan_type)
            
        except Exception as e:
            self.logger.error(f"Erreur r√©cup√©ration rapport: {e}")
            return self.create_error_report(str(e))
    
    def parse_openvas_report(self, xml_report, target, scan_type):
        """Parser un rapport OpenVAS XML"""
        try:
            root = ET.fromstring(xml_report)
            
            # Extraire les informations du scan
            scan_info = {
                'target': target,
                'scan_type': scan_type,
                'scan_date': datetime.now().isoformat(),
                'vulnerabilities': []
            }
            
            # Parser les r√©sultats
            results = root.findall('.//result')
            
            for result in results:
                vuln = {
                    'name': result.find('name').text if result.find('name') is not None else 'Unknown',
                    'severity': result.find('severity').text if result.find('severity') is not None else 'Unknown',
                    'description': result.find('description').text if result.find('description') is not None else '',
                    'solution': result.find('solution').text if result.find('solution') is not None else '',
                    'port': result.find('port').text if result.find('port') is not None else 'Unknown'
                }
                scan_info['vulnerabilities'].append(vuln)
            
            return self.generate_openvas_report(scan_info)
            
        except Exception as e:
            self.logger.error(f"Erreur parsing rapport: {e}")
            return self.create_error_report(str(e))
    
    def execute_gmp_command(self, command):
        """Ex√©cuter une commande GMP"""
        try:
            # Utiliser gvm-cli si disponible
            cmd = [
                'gvm-cli', 'socket',
                '--sockpath', '/run/gvmd/gvmd.sock',
                '--xml', command
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0:
                return result.stdout
            else:
                raise Exception(f"Erreur GMP: {result.stderr}")
                
        except subprocess.TimeoutExpired:
            raise Exception("Timeout de la commande GMP")
        except FileNotFoundError:
            raise Exception("gvm-cli non trouv√©")
    
    def schedule_scan(self, task_id, scheduled_time):
        """Programmer un scan"""
        self.logger.info(f"Programmation du scan {task_id} pour {scheduled_time}")
        
        # Dans une impl√©mentation r√©elle, on utiliserait les schedules OpenVAS
        # Ici on simule
        
        return {
            'task_id': task_id,
            'scheduled_time': scheduled_time,
            'status': 'scheduled',
            'message': f"Scan programm√© pour {scheduled_time}"
        }
    
    def bulk_scan(self, targets, scan_type='quick_scan'):
        """Lancer des scans en masse"""
        self.logger.info(f"D√©marrage de scans en masse sur {len(targets)} cibles")
        
        results = []
        
        for target in targets:
            try:
                result = self.automated_scan(target, scan_type)
                results.append({
                    'target': target,
                    'status': 'completed',
                    'result': result
                })
            except Exception as e:
                results.append({
                    'target': target,
                    'status': 'error',
                    'error': str(e)
                })
        
        return self.generate_bulk_report(results, scan_type)
    
    def generate_simulation_report(self, target, scan_type, config, vulnerabilities):
        """G√©n√©rer un rapport de simulation"""
        report = []
        report.append("=" * 60)
        report.append("OPENVAS AUTOMATED SCAN REPORT (SIMULATION)")
        report.append("=" * 60)
        report.append(f"Target: {target}")
        report.append(f"Scan Type: {config['name']}")
        report.append(f"Description: {config['description']}")
        report.append(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"Estimated Duration: {config['estimated_time']} minutes")
        report.append("")
        
        # Statistiques
        critical = sum(1 for v in vulnerabilities if v['severity'] == 'Critical')
        high = sum(1 for v in vulnerabilities if v['severity'] == 'High')
        medium = sum(1 for v in vulnerabilities if v['severity'] == 'Medium')
        low = sum(1 for v in vulnerabilities if v['severity'] == 'Low')
        
        report.append("VULNERABILITY SUMMARY")
        report.append("-" * 30)
        report.append(f"Critical: {critical}")
        report.append(f"High:     {high}")
        report.append(f"Medium:   {medium}")
        report.append(f"Low:      {low}")
        report.append(f"Total:    {len(vulnerabilities)}")
        report.append("")
        
        # D√©tails des vuln√©rabilit√©s
        if vulnerabilities:
            report.append("VULNERABILITY DETAILS")
            report.append("-" * 30)
            
            for i, vuln in enumerate(vulnerabilities, 1):
                report.append(f"{i}. {vuln['name']}")
                report.append(f"   Severity: {vuln['severity']} (CVSS: {vuln['cvss']})")
                if vuln['cve'] != 'N/A':
                    report.append(f"   CVE: {vuln['cve']}")
                report.append(f"   Port: {vuln['port']} ({vuln['service']})")
                report.append(f"   Description: {vuln['description']}")
                report.append(f"   Solution: {vuln['solution']}")
                report.append("")
        
        # Recommandations
        report.append("RECOMMENDATIONS")
        report.append("-" * 30)
        
        if critical > 0:
            report.append("üî¥ CRITICAL: Immediate action required!")
            report.append("   - Patch critical vulnerabilities immediately")
            report.append("   - Consider taking affected systems offline")
        
        if high > 0:
            report.append("üü† HIGH: Address within 48 hours")
            report.append("   - Schedule maintenance window for patching")
            report.append("   - Implement temporary mitigations")
        
        if medium > 0 or low > 0:
            report.append("üü° MEDIUM/LOW: Address during next maintenance cycle")
            report.append("   - Plan regular patching schedule")
            report.append("   - Review security configurations")
        
        report.append("")
        report.append("NOTE: This is a SIMULATED scan for demonstration purposes.")
        report.append("Real vulnerabilities may differ from this simulation.")
        
        return "\n".join(report)
    
    def generate_openvas_report(self, scan_info):
        """G√©n√©rer un rapport √† partir des donn√©es OpenVAS r√©elles"""
        report = []
        report.append("=" * 60)
        report.append("OPENVAS AUTOMATED SCAN REPORT")
        report.append("=" * 60)
        report.append(f"Target: {scan_info['target']}")
        report.append(f"Scan Type: {scan_info['scan_type']}")
        report.append(f"Scan Date: {scan_info['scan_date']}")
        report.append("")
        
        vulnerabilities = scan_info['vulnerabilities']
        
        # Statistiques
        severity_counts = {}
        for vuln in vulnerabilities:
            severity = vuln['severity']
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        report.append("VULNERABILITY SUMMARY")
        report.append("-" * 30)
        for severity, count in severity_counts.items():
            report.append(f"{severity}: {count}")
        report.append(f"Total: {len(vulnerabilities)}")
        report.append("")
        
        # D√©tails
        if vulnerabilities:
            report.append("VULNERABILITY DETAILS")
            report.append("-" * 30)
            
            for i, vuln in enumerate(vulnerabilities, 1):
                report.append(f"{i}. {vuln['name']}")
                report.append(f"   Severity: {vuln['severity']}")
                report.append(f"   Port: {vuln['port']}")
                if vuln['description']:
                    report.append(f"   Description: {vuln['description'][:200]}...")
                if vuln['solution']:
                    report.append(f"   Solution: {vuln['solution'][:200]}...")
                report.append("")
        
        return "\n".join(report)
    
    def generate_bulk_report(self, results, scan_type):
        """G√©n√©rer un rapport de scan en masse"""
        report = []
        report.append("=" * 60)
        report.append("BULK OPENVAS SCAN REPORT")
        report.append("=" * 60)
        report.append(f"Scan Type: {scan_type}")
        report.append(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"Total Targets: {len(results)}")
        report.append("")
        
        successful = sum(1 for r in results if r['status'] == 'completed')
        failed = len(results) - successful
        
        report.append("SUMMARY")
        report.append("-" * 20)
        report.append(f"Successful scans: {successful}")
        report.append(f"Failed scans: {failed}")
        report.append("")
        
        # D√©tails par cible
        for result in results:
            report.append(f"Target: {result['target']}")
            report.append(f"Status: {result['status']}")
            
            if result['status'] == 'error':
                report.append(f"Error: {result['error']}")
            
            report.append("")
        
        return "\n".join(report)
    
    def create_error_report(self, error_message):
        """Cr√©er un rapport d'erreur"""
        return f"""
=== OPENVAS SCAN ERROR ===
Error: {error_message}
Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Please check:
- OpenVAS/GVM service status
- Network connectivity
- Authentication credentials
- Target accessibility
"""
    
    def export_to_json(self, scan_data, filename=None):
        """Exporter les r√©sultats en JSON"""
        if not filename:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"openvas_scan_{timestamp}.json"
        
        with open(filename, 'w') as f:
            json.dump(scan_data, f, indent=2)
        
        return filename
    
    def get_scan_history(self):
        """Obtenir l'historique des scans"""
        return {
            'total_scans': len(self.scan_history),
            'recent_scans': self.scan_history[-10:],  # 10 derniers scans
            'available_configs': list(self.scan_configs.keys())
        }

def main():
    """Fonction principale pour tests"""
    openvas = OpenVASAutomation()
    
    target = input("Entrez l'IP cible: ").strip()
    if not target:
        target = "127.0.0.1"
    
    scan_type = input("Type de scan (quick_scan/full_scan/web_scan/network_scan): ").strip()
    if scan_type not in openvas.scan_configs:
        scan_type = "quick_scan"
    
    print(f"Lancement du scan OpenVAS {scan_type} sur {target}...")
    result = openvas.automated_scan(target, scan_type)
    print(result)

if __name__ == "__main__":
    main()