#!/usr/bin/env python3
"""
OpenVAS Automation pour CyberSec Pro
Module d'automatisation des scans de vulnérabilités avec OpenVAS
"""

import os
import time
import json
import subprocess
import xml.etree.ElementTree as ET
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import logging
import socket
import threading
from pathlib import Path

class OpenVASAutomation:
    """Automatisation des scans OpenVAS/GVM"""
    
    def __init__(self, gvm_host="127.0.0.1", gvm_port=9390, username="admin", password="admin"):
        self.gvm_host = gvm_host
        self.gvm_port = gvm_port
        self.username = username
        self.password = password
        
        # Configuration des scans
        self.scan_configs = self.load_scan_configurations()
        self.active_scans = {}
        self.scan_history = []
        
        self.setup_logging()
        self.check_openvas_status()
    
    def setup_logging(self):
        """Configuration du logging"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - OpenVASAutomation - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger(__name__)
    
    def check_openvas_status(self):
        """Vérifier le statut d'OpenVAS/GVM"""
        try:
            # Vérifier si le service GVM est accessible
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((self.gvm_host, self.gvm_port))
            sock.close()
            
            if result == 0:
                self.logger.info("OpenVAS/GVM détecté et accessible")
                self.openvas_available = True
            else:
                self.logger.warning("OpenVAS/GVM non accessible, mode simulation activé")
                self.openvas_available = False
                
        except Exception as e:
            self.logger.error(f"Erreur lors de la vérification OpenVAS: {e}")
            self.openvas_available = False
    
    def load_scan_configurations(self):
        """Charger les configurations de scan prédéfinies"""
        return {
            'quick_scan': {
                'name': 'Quick Vulnerability Scan',
                'description': 'Scan rapide des vulnérabilités critiques',
                'config_id': 'daba56c8-73ec-11df-a475-002264764cea',  # Full and fast
                'scanner_id': '08b69003-5fc2-4037-a479-93b440211c73',  # OpenVAS Scanner
                'port_list': 'T:1-65535',
                'estimated_time': 30,  # minutes
                'targets': []
            },
            'full_scan': {
                'name': 'Full Vulnerability Assessment',
                'description': 'Scan complet et approfondi',
                'config_id': '74db13d6-7489-11df-a475-002264764cea',  # Full and fast ultimate
                'scanner_id': '08b69003-5fc2-4037-a479-93b440211c73',
                'port_list': 'T:1-65535,U:1-1024',
                'estimated_time': 120,  # minutes
                'targets': []
            },
            'web_scan': {
                'name': 'Web Application Scan',
                'description': 'Scan spécialisé pour applications web',
                'config_id': '2d3f051c-55ba-11e3-bf43-406186ea4fc5',  # Web Application Tests
                'scanner_id': '08b69003-5fc2-4037-a479-93b440211c73',
                'port_list': 'T:80,443,8080,8443',
                'estimated_time': 45,
                'targets': []
            },
            'network_scan': {
                'name': 'Network Infrastructure Scan',
                'description': 'Scan des équipements réseau',
                'config_id': 'bbca7412-a950-11e3-9109-406186ea4fc5',  # System Discovery
                'scanner_id': '08b69003-5fc2-4037-a479-93b440211c73',
                'port_list': 'T:1-1024',
                'estimated_time': 60,
                'targets': []
            }
        }
    
    def automated_scan(self, target, scan_type='quick_scan', scheduled_time=None):
        """Lancer un scan automatisé"""
        self.logger.info(f"Démarrage du scan automatisé {scan_type} sur {target}")
        
        if not self.openvas_available:
            return self.simulate_openvas_scan(target, scan_type)
        
        try:
            # Créer la cible
            target_id = self.create_target(target)
            if not target_id:
                return self.create_error_report("Impossible de créer la cible")
            
            # Créer la tâche de scan
            task_id = self.create_scan_task(target_id, scan_type)
            if not task_id:
                return self.create_error_report("Impossible de créer la tâche de scan")
            
            # Programmer ou démarrer le scan
            if scheduled_time:
                return self.schedule_scan(task_id, scheduled_time)
            else:
                return self.start_scan_and_monitor(task_id, target, scan_type)
                
        except Exception as e:
            self.logger.error(f"Erreur lors du scan automatisé: {e}")
            return self.create_error_report(str(e))
    
    def simulate_openvas_scan(self, target, scan_type):
        """Simuler un scan OpenVAS quand le service n'est pas disponible"""
        self.logger.info(f"Simulation du scan OpenVAS {scan_type} sur {target}")
        
        config = self.scan_configs.get(scan_type, self.scan_configs['quick_scan'])
        
        # Simulation des vulnérabilités trouvées
        simulated_vulnerabilities = self.generate_simulated_vulnerabilities(target, scan_type)
        
        # Générer le rapport de simulation
        report = self.generate_simulation_report(target, scan_type, config, simulated_vulnerabilities)
        
        return report
    
    def generate_simulated_vulnerabilities(self, target, scan_type):
        """Générer des vulnérabilités simulées"""
        
        base_vulnerabilities = [
            {
                'name': 'OpenSSH Information Disclosure',
                'severity': 'Medium',
                'cvss': 5.3,
                'cve': 'CVE-2018-15473',
                'port': 22,
                'service': 'ssh',
                'description': 'OpenSSH user enumeration vulnerability',
                'solution': 'Update OpenSSH to latest version'
            },
            {
                'name': 'Apache HTTP Server Information Disclosure',
                'severity': 'Low',
                'cvss': 2.6,
                'cve': 'CVE-2019-0220',
                'port': 80,
                'service': 'http',
                'description': 'Apache HTTP Server mod_auth_digest denial of service',
                'solution': 'Update Apache to version 2.4.39 or later'
            },
            {
                'name': 'SSL/TLS Weak Cipher Suites',
                'severity': 'Medium',
                'cvss': 4.3,
                'cve': 'N/A',
                'port': 443,
                'service': 'https',
                'description': 'Weak cipher suites detected',
                'solution': 'Configure strong cipher suites'
            }
        ]
        
        # Vulnérabilités spécifiques selon le type de scan
        if scan_type == 'web_scan':
            base_vulnerabilities.extend([
                {
                    'name': 'Cross-Site Scripting (XSS)',
                    'severity': 'High',
                    'cvss': 6.1,
                    'cve': 'N/A',
                    'port': 80,
                    'service': 'http',
                    'description': 'Reflected XSS vulnerability detected',
                    'solution': 'Implement input validation and output encoding'
                },
                {
                    'name': 'SQL Injection',
                    'severity': 'Critical',
                    'cvss': 9.8,
                    'cve': 'N/A',
                    'port': 80,
                    'service': 'http',
                    'description': 'SQL injection vulnerability in login form',
                    'solution': 'Use parameterized queries'
                }
            ])
        
        elif scan_type == 'full_scan':
            base_vulnerabilities.extend([
                {
                    'name': 'SMB Signing Not Required',
                    'severity': 'Medium',
                    'cvss': 5.9,
                    'cve': 'N/A',
                    'port': 445,
                    'service': 'smb',
                    'description': 'SMB signing is not required',
                    'solution': 'Enable SMB signing'
                },
                {
                    'name': 'Outdated Operating System',
                    'severity': 'High',
                    'cvss': 7.5,
                    'cve': 'Multiple',
                    'port': 0,
                    'service': 'general',
                    'description': 'Operating system is not up to date',
                    'solution': 'Install latest security updates'
                }
            ])
        
        return base_vulnerabilities
    
    def create_target(self, target_ip):
        """Créer une cible dans OpenVAS"""
        if not self.openvas_available:
            return f"simulated_target_{target_ip}"
        
        # Commande GMP pour créer une cible
        gmp_command = f"""
        <create_target>
            <name>Target_{target_ip}_{int(time.time())}</name>
            <hosts>{target_ip}</hosts>
            <port_list id="4a4717fe-57d2-11e1-9a26-406186ea4fc5"/>
        </create_target>
        """
        
        try:
            result = self.execute_gmp_command(gmp_command)
            # Parser la réponse XML pour extraire l'ID
            root = ET.fromstring(result)
            target_id = root.get('id')
            return target_id
        except Exception as e:
            self.logger.error(f"Erreur création cible: {e}")
            return None
    
    def create_scan_task(self, target_id, scan_type):
        """Créer une tâche de scan"""
        if not self.openvas_available:
            return f"simulated_task_{scan_type}_{int(time.time())}"
        
        config = self.scan_configs.get(scan_type, self.scan_configs['quick_scan'])
        
        gmp_command = f"""
        <create_task>
            <name>{config['name']}_{int(time.time())}</name>
            <config id="{config['config_id']}"/>
            <target id="{target_id}"/>
            <scanner id="{config['scanner_id']}"/>
        </create_task>
        """
        
        try:
            result = self.execute_gmp_command(gmp_command)
            root = ET.fromstring(result)
            task_id = root.get('id')
            return task_id
        except Exception as e:
            self.logger.error(f"Erreur création tâche: {e}")
            return None
    
    def start_scan_and_monitor(self, task_id, target, scan_type):
        """Démarrer un scan et le monitorer"""
        self.logger.info(f"Démarrage du scan {task_id}")
        
        if not self.openvas_available:
            return self.simulate_scan_monitoring(task_id, target, scan_type)
        
        # Démarrer la tâche
        start_command = f'<start_task task_id="{task_id}"/>'
        
        try:
            self.execute_gmp_command(start_command)
            
            # Monitorer le scan
            return self.monitor_scan_progress(task_id, target, scan_type)
            
        except Exception as e:
            self.logger.error(f"Erreur démarrage scan: {e}")
            return self.create_error_report(str(e))
    
    def simulate_scan_monitoring(self, task_id, target, scan_type):
        """Simuler le monitoring d'un scan"""
        config = self.scan_configs.get(scan_type, self.scan_configs['quick_scan'])
        
        self.logger.info(f"Simulation du scan en cours... (durée estimée: {config['estimated_time']} min)")
        
        # Simuler la progression
        progress_steps = [10, 25, 50, 75, 90, 100]
        
        for progress in progress_steps:
            self.logger.info(f"Progression du scan: {progress}%")
            time.sleep(1)  # Simulation rapide
        
        # Générer le rapport final
        vulnerabilities = self.generate_simulated_vulnerabilities(target, scan_type)
        return self.generate_simulation_report(target, scan_type, config, vulnerabilities)
    
    def monitor_scan_progress(self, task_id, target, scan_type):
        """Monitorer la progression d'un scan réel"""
        config = self.scan_configs.get(scan_type, self.scan_configs['quick_scan'])
        start_time = datetime.now()
        
        while True:
            try:
                # Obtenir le statut de la tâche
                status_command = f'<get_tasks task_id="{task_id}"/>'
                result = self.execute_gmp_command(status_command)
                
                root = ET.fromstring(result)
                task = root.find('.//task')
                
                if task is not None:
                    status = task.find('status').text
                    progress = task.find('progress').text
                    
                    self.logger.info(f"Scan {task_id}: {status} - {progress}%")
                    
                    if status == 'Done':
                        # Obtenir le rapport
                        return self.get_scan_report(task_id, target, scan_type)
                    elif status == 'Stopped' or status == 'Interrupted':
                        return self.create_error_report(f"Scan arrêté: {status}")
                
                # Vérifier le timeout
                if datetime.now() - start_time > timedelta(minutes=config['estimated_time'] * 2):
                    return self.create_error_report("Timeout du scan")
                
                time.sleep(30)  # Attendre 30 secondes avant la prochaine vérification
                
            except Exception as e:
                self.logger.error(f"Erreur monitoring: {e}")
                return self.create_error_report(str(e))
    
    def get_scan_report(self, task_id, target, scan_type):
        """Récupérer le rapport de scan"""
        try:
            # Obtenir l'ID du dernier rapport pour cette tâche
            reports_command = f'<get_reports task_id="{task_id}"/>'
            result = self.execute_gmp_command(reports_command)
            
            root = ET.fromstring(result)
            reports = root.findall('.//report')
            
            if not reports:
                return self.create_error_report("Aucun rapport trouvé")
            
            # Prendre le dernier rapport
            latest_report = reports[-1]
            report_id = latest_report.get('id')
            
            # Obtenir le contenu détaillé du rapport
            detailed_command = f'<get_reports report_id="{report_id}" format_id="a994b278-1f62-11e1-96ac-406186ea4fc5"/>'
            detailed_result = self.execute_gmp_command(detailed_command)
            
            return self.parse_openvas_report(detailed_result, target, scan_type)
            
        except Exception as e:
            self.logger.error(f"Erreur récupération rapport: {e}")
            return self.create_error_report(str(e))
    
    def parse_openvas_report(self, xml_report, target, scan_type):
        """Parser un rapport OpenVAS XML"""
        try:
            root = ET.fromstring(xml_report)
            
            # Extraire les informations du scan
            scan_info = {
                'target': target,
                'scan_type': scan_type,
                'scan_date': datetime.now().isoformat(),
                'vulnerabilities': []
            }
            
            # Parser les résultats
            results = root.findall('.//result')
            
            for result in results:
                vuln = {
                    'name': result.find('name').text if result.find('name') is not None else 'Unknown',
                    'severity': result.find('severity').text if result.find('severity') is not None else 'Unknown',
                    'description': result.find('description').text if result.find('description') is not None else '',
                    'solution': result.find('solution').text if result.find('solution') is not None else '',
                    'port': result.find('port').text if result.find('port') is not None else 'Unknown'
                }
                scan_info['vulnerabilities'].append(vuln)
            
            return self.generate_openvas_report(scan_info)
            
        except Exception as e:
            self.logger.error(f"Erreur parsing rapport: {e}")
            return self.create_error_report(str(e))
    
    def execute_gmp_command(self, command):
        """Exécuter une commande GMP"""
        try:
            # Utiliser gvm-cli si disponible
            cmd = [
                'gvm-cli', 'socket',
                '--sockpath', '/run/gvmd/gvmd.sock',
                '--xml', command
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            if result.returncode == 0:
                return result.stdout
            else:
                raise Exception(f"Erreur GMP: {result.stderr}")
                
        except subprocess.TimeoutExpired:
            raise Exception("Timeout de la commande GMP")
        except FileNotFoundError:
            raise Exception("gvm-cli non trouvé")
    
    def schedule_scan(self, task_id, scheduled_time):
        """Programmer un scan"""
        self.logger.info(f"Programmation du scan {task_id} pour {scheduled_time}")
        
        # Dans une implémentation réelle, on utiliserait les schedules OpenVAS
        # Ici on simule
        
        return {
            'task_id': task_id,
            'scheduled_time': scheduled_time,
            'status': 'scheduled',
            'message': f"Scan programmé pour {scheduled_time}"
        }
    
    def bulk_scan(self, targets, scan_type='quick_scan'):
        """Lancer des scans en masse"""
        self.logger.info(f"Démarrage de scans en masse sur {len(targets)} cibles")
        
        results = []
        
        for target in targets:
            try:
                result = self.automated_scan(target, scan_type)
                results.append({
                    'target': target,
                    'status': 'completed',
                    'result': result
                })
            except Exception as e:
                results.append({
                    'target': target,
                    'status': 'error',
                    'error': str(e)
                })
        
        return self.generate_bulk_report(results, scan_type)
    
    def generate_simulation_report(self, target, scan_type, config, vulnerabilities):
        """Générer un rapport de simulation"""
        report = []
        report.append("=" * 60)
        report.append("OPENVAS AUTOMATED SCAN REPORT (SIMULATION)")
        report.append("=" * 60)
        report.append(f"Target: {target}")
        report.append(f"Scan Type: {config['name']}")
        report.append(f"Description: {config['description']}")
        report.append(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"Estimated Duration: {config['estimated_time']} minutes")
        report.append("")
        
        # Statistiques
        critical = sum(1 for v in vulnerabilities if v['severity'] == 'Critical')
        high = sum(1 for v in vulnerabilities if v['severity'] == 'High')
        medium = sum(1 for v in vulnerabilities if v['severity'] == 'Medium')
        low = sum(1 for v in vulnerabilities if v['severity'] == 'Low')
        
        report.append("VULNERABILITY SUMMARY")
        report.append("-" * 30)
        report.append(f"Critical: {critical}")
        report.append(f"High:     {high}")
        report.append(f"Medium:   {medium}")
        report.append(f"Low:      {low}")
        report.append(f"Total:    {len(vulnerabilities)}")
        report.append("")
        
        # Détails des vulnérabilités
        if vulnerabilities:
            report.append("VULNERABILITY DETAILS")
            report.append("-" * 30)
            
            for i, vuln in enumerate(vulnerabilities, 1):
                report.append(f"{i}. {vuln['name']}")
                report.append(f"   Severity: {vuln['severity']} (CVSS: {vuln['cvss']})")
                if vuln['cve'] != 'N/A':
                    report.append(f"   CVE: {vuln['cve']}")
                report.append(f"   Port: {vuln['port']} ({vuln['service']})")
                report.append(f"   Description: {vuln['description']}")
                report.append(f"   Solution: {vuln['solution']}")
                report.append("")
        
        # Recommandations
        report.append("RECOMMENDATIONS")
        report.append("-" * 30)
        
        if critical > 0:
            report.append("🔴 CRITICAL: Immediate action required!")
            report.append("   - Patch critical vulnerabilities immediately")
            report.append("   - Consider taking affected systems offline")
        
        if high > 0:
            report.append("🟠 HIGH: Address within 48 hours")
            report.append("   - Schedule maintenance window for patching")
            report.append("   - Implement temporary mitigations")
        
        if medium > 0 or low > 0:
            report.append("🟡 MEDIUM/LOW: Address during next maintenance cycle")
            report.append("   - Plan regular patching schedule")
            report.append("   - Review security configurations")
        
        report.append("")
        report.append("NOTE: This is a SIMULATED scan for demonstration purposes.")
        report.append("Real vulnerabilities may differ from this simulation.")
        
        return "\n".join(report)
    
    def generate_openvas_report(self, scan_info):
        """Générer un rapport à partir des données OpenVAS réelles"""
        report = []
        report.append("=" * 60)
        report.append("OPENVAS AUTOMATED SCAN REPORT")
        report.append("=" * 60)
        report.append(f"Target: {scan_info['target']}")
        report.append(f"Scan Type: {scan_info['scan_type']}")
        report.append(f"Scan Date: {scan_info['scan_date']}")
        report.append("")
        
        vulnerabilities = scan_info['vulnerabilities']
        
        # Statistiques
        severity_counts = {}
        for vuln in vulnerabilities:
            severity = vuln['severity']
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        report.append("VULNERABILITY SUMMARY")
        report.append("-" * 30)
        for severity, count in severity_counts.items():
            report.append(f"{severity}: {count}")
        report.append(f"Total: {len(vulnerabilities)}")
        report.append("")
        
        # Détails
        if vulnerabilities:
            report.append("VULNERABILITY DETAILS")
            report.append("-" * 30)
            
            for i, vuln in enumerate(vulnerabilities, 1):
                report.append(f"{i}. {vuln['name']}")
                report.append(f"   Severity: {vuln['severity']}")
                report.append(f"   Port: {vuln['port']}")
                if vuln['description']:
                    report.append(f"   Description: {vuln['description'][:200]}...")
                if vuln['solution']:
                    report.append(f"   Solution: {vuln['solution'][:200]}...")
                report.append("")
        
        return "\n".join(report)
    
    def generate_bulk_report(self, results, scan_type):
        """Générer un rapport de scan en masse"""
        report = []
        report.append("=" * 60)
        report.append("BULK OPENVAS SCAN REPORT")
        report.append("=" * 60)
        report.append(f"Scan Type: {scan_type}")
        report.append(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"Total Targets: {len(results)}")
        report.append("")
        
        successful = sum(1 for r in results if r['status'] == 'completed')
        failed = len(results) - successful
        
        report.append("SUMMARY")
        report.append("-" * 20)
        report.append(f"Successful scans: {successful}")
        report.append(f"Failed scans: {failed}")
        report.append("")
        
        # Détails par cible
        for result in results:
            report.append(f"Target: {result['target']}")
            report.append(f"Status: {result['status']}")
            
            if result['status'] == 'error':
                report.append(f"Error: {result['error']}")
            
            report.append("")
        
        return "\n".join(report)
    
    def create_error_report(self, error_message):
        """Créer un rapport d'erreur"""
        return f"""
=== OPENVAS SCAN ERROR ===
Error: {error_message}
Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Please check:
- OpenVAS/GVM service status
- Network connectivity
- Authentication credentials
- Target accessibility
"""
    
    def export_to_json(self, scan_data, filename=None):
        """Exporter les résultats en JSON"""
        if not filename:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"openvas_scan_{timestamp}.json"
        
        with open(filename, 'w') as f:
            json.dump(scan_data, f, indent=2)
        
        return filename
    
    def get_scan_history(self):
        """Obtenir l'historique des scans"""
        return {
            'total_scans': len(self.scan_history),
            'recent_scans': self.scan_history[-10:],  # 10 derniers scans
            'available_configs': list(self.scan_configs.keys())
        }

def main():
    """Fonction principale pour tests"""
    openvas = OpenVASAutomation()
    
    target = input("Entrez l'IP cible: ").strip()
    if not target:
        target = "127.0.0.1"
    
    scan_type = input("Type de scan (quick_scan/full_scan/web_scan/network_scan): ").strip()
    if scan_type not in openvas.scan_configs:
        scan_type = "quick_scan"
    
    print(f"Lancement du scan OpenVAS {scan_type} sur {target}...")
    result = openvas.automated_scan(target, scan_type)
    print(result)

if __name__ == "__main__":
    main()